[{"title":"基于Zlib的c++流式解压","date":"2022-12-15T07:27:00.000Z","url":"/2022/12/15/zlib-stream-uncompress/","tags":[["zlib","/tags/zlib/"],["c++","/tags/c/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"前言因为前段时间开源了一个用 C++ 实现的高性能 dex 运行时解析库DexKit. 然后里面借鉴了哔哩漫游里面的解压代码，然后在中途也因为有部分APK的格式解析不了，又去学习了zip文件的格式并且修了修bug，不过这都是后话了。 为什么要提起这个东西呢，因为前几天有人反馈说MIUI14的手机管家APK解析不出东西了，然后我第一反应是是不是路径填错了？但是反复确认后发现确实是解压不出来APK里面的dex文件，就开始了漫长的调试之旅。 解惑历程首先我们先了解一下Zip文件的格式，当然我们只会选择其中几个需要的部分来讲述，如果想要了解完整的格式，请自行查看官方文档ZIP File Format Specification。 ZIP文件的结构根据官方文档所述，ZIP文件的整体结构如下所示： 我们只会选择其中与文件相关的3个结构来分析： local file header：代表文件的头部信息，包含文件名、文件大小、文件的压缩方式等信息。 file data：代表文件的数据，如果文件没有压缩，那么这个数据就是文件的原始数据，如果文件被压缩了，那么这个数据就是压缩后的数据。 data descriptor（可选）：代表文件的数据描述符，如果文件被压缩了，那么这个数据描述符就会包含文件的原始大小，如果文件没有被压缩，那么这个数据描述符就会和local file header中的数据描述符一样。 每个被打包进ZIP的文件都会存在这样顺序存在的数据区域（data descriptor 不一定会在所有的zip文件中出现，这个我们后面再提），然后就是下一个文件的数据区域，以此类推。 接下来我们看一下 local file header 的结构： 首先是LocalFileHeader的签名，这个签名固定为(0x04034b50)，我们一般都会用这个来判断是否存在下一个文件的数据区域。然后里面比较重要的就是 compressed size 与 uncompressed size ，这两个字段分别代表压缩后的文件大小与原始文件大小，如果文件没有被压缩，那么这两个字段的值就是一样的。但是！！！不是所有的压缩文件都会按照标准来填充这两个字段，这也是我们开头提到问题的罪魁祸首。MIUI 14 的手机管家所有的压缩资源，将这两个字段全部填充为0，让我一度怀疑这是故意的还是打包工具的问题。 上面我们提到了，下一个文件是紧跟着上一个文件的 file data 或者 data descriptor 区域，现在我们从 header 中获取到的信息是 file data 区域的大小为0，此时开始陷入了僵局，我开始思考应该怎样处理这个问题。因为这个未定义行为，在使用 010 editor 打开 apk 进行分析的过程中也会存在解析异常的问题。 根据上面的已知信息，我们已知 local file header signature 是固定值，难道我们需要暴力往后遍历搜索下一个文件的签名才能判断数据吗？不，正常的压缩软件以及 JAVA 中的 ZipInputStream 都能正常打开并且解压这个非标准格式的APK文件，一定存在一个稳妥的方式解决我们的问题。 zlib格式看到这个小节的标题，有的人可能会想：“什么？zlib不是一个库吗，怎么是一个格式？？？”。没错，zlib是一种数据格式，它的算法与格式都是公开的，我们先搞清楚几个相关的概念： zlib 是一种数据格式，用于存储压缩后的数据 gzip 也是一种数据格式，也用于存储压缩后的数据，不过它只保存单个文件 zip 文件是一种归档格式，它用来存储多个经过压缩后的 zlib 文件集合 deflate 是压缩算法，zlib 与 gzip 都使用它来压缩文件 inflate 是对应 deflate 算法的解压算法 既然 zlib 是一种数据格式，那么它是否能得知自身的文件大小呢？是的，inflate 算法在解压过程中可以做到自终止，当读取到了超出数据本身的区域会停止读取，并且将信息返回，我们可以在这上面做文章解决我们开头的问题。 解决方案通过对于 zlib 格式的相关了解，我们可以重新定制以下我们原本的解压步骤： 读取 apk 文件，获取第一个 local file header。 判断 header 中的 compressed size 是否为0，如果为0，我们假设这是错误的数据，我们获取数据区域的指针，并且将它开始的一部分数据作为本压缩文件的数据传递给 inflate 函数尝试解压，如果读取字节数为0，则表示数据区域确实为0，否则逐步向后读取尝试解压，直到 inflate 算法终止。到这里我们可以获得总共读取了多少字节，以及解压后的字节数。将真实值填充回结构体。 解析完所有的 LocalFile 数据区域，并且将 fileName 以及 data 区域的指针存入 map。 暴力查找 classes.dex, classes2.dex, .., classesN.dex, 逐一解压，再将数据交给 DexKit 进行后续处理。 这里给出我的处理方式作为参考，如果想实现一个类似 JAVA 的 ZipInputStream 可以尝试自己封装一下。 zip_helper.h End至此，问题的定位、分析、追踪以及修复处理总算告一段落，愿世上再无未定义"},{"title":"spock初探","date":"2021-12-29T07:27:00.000Z","url":"/2021/12/29/spock-spring2-study-note1/","tags":[["springboot","/tags/springboot/"],["spock","/tags/spock/"],["测试","/tags/%E6%B5%8B%E8%AF%95/"],["瞎说","/tags/%E7%9E%8E%E8%AF%B4/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"背景项目维护的久了，业务逻辑就会因为需求导致越来越多的分支，也可能在开发过程中cv的时候疏忽，忘记修改了一个参数，直到上线的时候bug才体现出来。这就陷入了一个没有测试导致开发过程中的bug带入了线上环境的尴尬境地。 实际上一直都想找个时间对项目写一份测试，正常的测试框架实在太难用，再加上没有太多的时间，所以这个事情一拖再拖，在前阵子无意中看到了一款测试框架——Spock，稍微了解了一下后想尝试一下这个框架来编写测试。前几天终于忙完了OJ的改造，立马就来玩玩spock了。 网上关于Spock的资料比较简单，包括官网的demo也是如此，并且因为spock2增加了很多特性（目前还在不断的更新中），网上的资料存在过多的过时内容，所以在写的过程中遇见了无数的问题，不过总算是解决了，所以写篇博客来记录一下。 Junit单元测试的痛点现在我有一个AccountInput的DTO用来接收前端请求，其父类BaseDTO提供了2个final方法： convert：将dto转换成对应的实体类 convertAndUpdate：将DTO中的字段对实体的相应字段进行覆盖。 但是有些字段我不需要覆盖怎么办，所以额外提供了一个@CopyIgnore注解用于忽略 convert&#x2F;update 过程中某些不需要覆盖的字段 AccountInput.class BaseDTO.class 然后我们就针对这部分逻辑取编写一份正常的junit测试来康康，为了确保测试的完善，我们的测试肯定得有多组输入，多组输入的方式有很多种，这里我们先采用一个相对简单方便的@CsvSource来进行多组测试用例的输入。 junit测试代码及结果 通过上面的代码我们可以发现，所有参数都是通过字符串方式进行传递然后通过切面获取测试的参数类型然后再转换成对应的类型进行注入的。在默认情况下空字符串会视为null进行参数注入，那么如果我们需要注入空字符串给String对象怎么办？手动将CsvSource#nullValues()设置为一个代表null的字符串即可（例如&quot;None&quot;），但是这又引入了一个新的问题，我有些时候需要None这个字符串怎么办，所以这时候就陷入了对象通过字符串表达造成矛盾之中。 通过@Parameters与DataProvider的方式虽然可以解决，但是无论哪个方法都比较复杂，往往一个十几行的代码，需要几十行甚至上百行的代码进行测试，而且采用@Parameters进行参数注入，需要构造函数进行配合，那么就变成了需要一整个测试类来测试一个方法。 junit测试代码及结果 不过最让我动心的还是spock对于条件分支测试的直观程度，这里上个图举个简单的例子（当然这个例子举的可能不够好） 如果在if/else很多的复杂场景下，编写测试代码的成本就很高，为了分支的覆盖率，编写的测试代码长度可能远远超过了被测试的代码。当然JUnit的@Parametered参数化注解或者DataProvider可以解决多数据分支问题，但是编写起来非常麻烦，而且不够直观，如果某个用例出错报错也不够详细。 但是spock的where标签，基于spock得天独厚的数据表语法糖，测试代码覆盖所有的if分支逻辑，我们要做的仅仅是编写一份表格，就能完成一份复杂的分支测试，开发效率更高，更适合敏捷开发。 "},{"title":"记录一次startUML破解","date":"2019-12-02T07:28:51.000Z","url":"/2019/12/02/startuml3.1.1-crack/","tags":[["StartUML","/tags/StartUML/"],["破解","/tags/%E7%A0%B4%E8%A7%A3/"]],"categories":[["摸鱼日常","/categories/%E6%91%B8%E9%B1%BC%E6%97%A5%E5%B8%B8/"]],"content":"前言之前startUML还在3.1.0的时候其实已经破解过一次了，网上的破解教程其实也有很多。讲道理现在startUML的颜值还是很高的。startUML目前的版本都是通过electron打包生成的软件，纯前端开发的东西，并且代码清晰，该有注释有注释，业务逻辑一点混淆都没做，搞得我破解的怪不好意思的。我没有搞事情！但是因为最近StartUML 3.1.1版本发布，发现退出时会强制弹出更新，怪难受的，上次没注意选了是，结果瞬间给我装完了。更加增加了我去除更新的决心。 破解步骤0x0.前置工作1.首先电脑应该安装node环境，这我就不介绍了，各位自行下载。2.安装asar包，为后面的解压app.asar做准备npm install asar -g，-g参数是全局安装，node的工作机制我也不介绍了（嘘，其实是我不懂，就是一个弱鸡前端）。3.找到startUML安装目录，找到resources文件夹，里面的app.asar就是我们的目标了。4.打开命令行使用npm extract app.asar app将app.asar的文件解压到app文件夹。 0x1.破解license校验license校验的文件就在app/src/engine/license-manager.js中，打开文件我们可以看到这样一段代码: 很显然这就是我们本次的目标惹！但是网上几乎全部的破解的步骤都是只改了2行代码: 虽然这样确实so easy的就将startUML的license校验给干掉了，但是主动输入密钥的话还是会提示秘钥无效，破解的一点都不完整，这才不是我想要的破解！（PS：小声逼逼，真的没见过比这个更容易的破解了） 我们现在分析一下其余部分的代码 仔细分析一下代码，我们可以得知到了所有的判断逻辑，那么我们只需要将服务器相关的逻辑干掉即可，只保留读取文件以及回调的逻辑： 然后再将licenseKey注册部分逻辑解决即可，这是原逻辑： 这部分逻辑就是注册license的逻辑了，逻辑理解没有任何难度，是不是还记得上面有一段哈希的操作我们照着键值原样仿制一个license的json对象即可： 破解到这里可以基本告一段落了，软件是能使用了，但是更新的问题还没解决呢，如果startUML检测到版本有更新，或者手动误操作点击了更新，依旧是会进行后台下载不需要经过你二次同意的。 0x2.去除启动更新检测这部分逻辑比我想象中的难找了一点，我还纳闷了一会，他到底是怎么做到关闭软件时再弹出安装操作的，然后经历了几次卸载，观察发现，当软件开启时就会检测是否有更新，如果有则立马开启后台下载，网速嗖嗖嗖的飚，路径下载到了AppData\\Roaming\\StarUML这个路径下，下载完成后，如果关闭软件，则会立马触发安装操作。 这部分逻辑在app/src/main-process/application.js文件下注释一句： 此外engin目录下还有一个update-manager.js，注释后，手动检测更新依旧返回已经是最新版无需更新的字样： 0x3.破解完成现在我们已经获得了破解完成，最后我们在根目录使用asar pack app app.asar将app文件夹打包成asar文件，最后将文件替换进原路径即可。 结语破解方式至3.1.1依旧有效，不保证未来不会发生变化，仅供参考。 曾经我们上课的时候，使用的startUML的颜值，那真的是一言难尽，可能我校用的还是1.0的上古版本（最主要是教材还对的上），太恐怖了，不过现在startUML 3.x的颜值真的很不错，QAQ虽然这也不是我破解的理由。好了好了，我这条咸鱼又滚回去过我的咸鱼生活惹！告辞~"},{"title":"SpringBoot接收LocalDateTime最佳实践","date":"2019-11-05T01:12:30.000Z","url":"/2019/11/05/springboot-backend-receive-localdatetime/","tags":[["SpringBoot","/tags/SpringBoot/"],["Java","/tags/Java/"],["后端","/tags/%E5%90%8E%E7%AB%AF/"]],"categories":[["笔记","/categories/%E7%AC%94%E8%AE%B0/"]],"content":"0x0. LocalDateTime在SpringBoot中的窘境问题由来：在前不久，我们后台就已经抛弃了Date这个类，而改用了java8提供的LocalDateTime，但是正常情况下LocalDateTime的构造函数是私有的，无法像Date那样直接被spring mvc直接处理，所以带给了我很多困扰，甚至有一次项目急迫致使我直接使用String去对时间进行接收，然后再通过DateTimeFormatter在Controller层对参数进行了一层处理，才能将LocalDateTime传给了Service进行处理，直接导致的结果就是方法变得有点丑陋了（逃~ 0x1. 初步解决LocalDateTime作为query参数的问题经过多方面查询得知，对于java8时间格式的问题，其实困扰着很多人，网上也提供了很多的解决方案，比如说下面这种在query参数上加注解的方式： 请求结果如下： 但是这样造成的后果是严重影响了代码的质量，每个使用LocalDateTime的参数的地方都需要使用两个注解。 0x2. 寻找全局解决方式接着我又继续尝试了这一种在加了@Configuration的类中使用@Bean注入了一个Convert转换器的方式就是一种很常见的方法（PS：LocalDateTimeUtils是我自己写的一个工具类，后面再提）: Controller层代码： 但是我使用过后却并没有得到我想要的效果，出现了报错，这是为什么？得到的报错如下java.lang.IllegalStateException: No primary or default constructor found for class java.time.LocalDateTime，仔细想了一下为什么别人能使用呢，后面才发现自己缺少了一个注解@RequestParam，好的，我这就去加上： 请求结果： nice！全局方式query也生效了，现在我们来尝试一下使用Model去接收参数： TestModel: Controller层： 请求结果： 嗯，现在已经大致满足要求了，但是对于简洁到了极致的自己来说却依旧不能感到满足，为什么LocalDateTime作为一个属性存在于Model中时却不需要使用注解方式去指定呢？而我们不使用@RequestParam时LocalDateTime却会出现报错？ 0x3. 深入研究分析参数转换过程我们先在先在Controller层下一个断点，然后查看调用堆栈，找到了一个可疑的方法：invokeForRequest 我们点进去看一看： 我们展开参数解析器的列表： 是不是看到了几个看着很眼熟的东西？RequestParam,PathVariable,RequestBody，在idea中查找RequestParamMethodArgumentResolver类，进入他的方法看一下， 这里可以基本确定一件事，在我这测试时默认的参数解析器有26个，每个参数解析器有着各自的用途，比如加了@RequestParam注解的参数会被RequestParamMethodArgumentResolver所解析，然后再查找类型有无相应的Convert转换器，在我们这里使用@Bean注入了一个Convert转换器，所以LocalDateTime能被正确的解析。 那么我们之前不加@RequestParam直接使用LocalDateTime作为参数的时候是被哪个解析器所捕获的呢，方法已经找到了，那么直接下个断点跑一遍查看result返回的是哪个解析器就知道了！ 如果没记错ServletModelAttributeMethodProcessor是参数解析器的最后一个，我们进入到这个类看一眼，没有supportsParameter方法，但是他继承了ModelAttributeMethodProcessor，我们再进入他的父类中： 对于没有指定参数解析器的参数来说，默认指定的参数解析器是ModelAttributeMethodProcessor，并且由源码得知，如果加了@ModelAttribute注解，或者非简单属性则会被该解析器捕获，所以我们平时所使用的model去接收不需要加注解即可被正确的解析，既然都来了，那么顺便看一下resolveArgument方法是怎么解析参数的 继续跟进createAttribute方法，看看他是怎么将值绑定给对象的： 看到这里是不是发现报错的地方有点熟悉？这就是我们之前LocalDateTime抛出异常的地方了，可以得知对于对象的绑定，先通过BeanUtils获取主要的构造函数，如果获取不到，则使用反射的方式先尝试获取声明为public的无参构造函数，最后才会尝试使用getDeclaredConstructor获取所有的无参构造函数，但是对于LocalDateTime这种使用工厂构造不存在无参构造函数的类来说就会直接抛出NoSuchMethodException异常。那么如果我们不想使用@RequestParam注解加在参数上怎么办呢？ 0x4. 创建参数解析器如果我们不希望在LocalDateTime上增加注解，然后再通过RequestParamMethodArgumentResolver解析，我们可以自己定制一种针对LocalDateTime的参数解析器，通过继承WebMvcConfigurer重写addArgumentResolvers方法，然后add一个自定义的HandlerMethodArgumentResolver即可解决刚才的问题，但是在2.2.0版本上会自动指定LocalDateTime的解析器原因未知（我太蔡了…找不到是怎么做到的，想看看他是怎么获取的，但是发现那个方法再无限调用，完全没有头绪。 0x5. 推荐使用注册Convert的方式相比于注入@Bean的方式创建Convert的方式，我个人更喜欢使用继承WebMvcConfigurer后重写addFormatters方法来注册自定义Convert。这种方式相比于@Bean注入，更容易让人理解，代码如下： 0x6. 小结对于request参数其实还有initBinder，Formatter等方式进行处理，这里就不一一贴出来了，有兴趣的各位可以在网上查询相关资料。还有jackson相关的序列化，通过继承com.fasterxml.jackson.databind.JsonDeserializer和com.fasterxml.jackson.databind.JsonSerializer生成自定义的Jackson Deserializer和Serializer，然后在@Configuration注解的配置类内注入@Bean将Jackson Module注册为@Bean，SpringBoot会自动注入进ObjectMapper中。另一种方式是自己注入一个自己定制的ObjectMapper为@Bean，然后将Module注入进ObjectMapper中。甚至可以通过定制转换规则，从而使类型支持多种参数。 0xf. 附录时间字符串转 LocalDateTime 工具类。转换不同时区的时间为本地时间（默认使用 ZoneId.systemDefault() 为本地时区） 支持10位秒时间戳 13位毫秒时间戳 通用时间格式: yyyy-MM-dd HH:mm[:ss][.sss] ISO-8601 时间格式: yyyy-MM-ddTHH:mm[:ss][.sss][Z|(+|-)HH:mm] RFC-3339 时间格式: yyyy-MM-dd HH:mm[:ss][.sss][Z|(+|-)HH:mm] "},{"title":"博客终于搭好了","date":"2019-10-31T07:10:53.000Z","url":"/2019/10/31/blog-create/","categories":[["摸鱼日常","/categories/%E6%91%B8%E9%B1%BC%E6%97%A5%E5%B8%B8/"]],"content":"博客搭好其实也有好几天了，但是被耽搁了一阵子，虽然最近很忙，但是还是下定决心来写一些东西，方便自己也方便他人。其实很多时候都想记录一些容易忘记的东西，但是总觉得写博客太麻烦，所以一拖再拖。现实习中，java后台一枚，开发使用SpringBoot，一起来学习吧！ "}]